<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Moilk Blog</title>
    <description>Moilk的个人博客</description>
    <link>http://127.0.0.1:4000/Blog/</link>
    <atom:link href="http://127.0.0.1:4000/Blog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 09 Nov 2015 01:57:18 -0800</pubDate>
    <lastBuildDate>Mon, 09 Nov 2015 01:57:18 -0800</lastBuildDate>
    <generator>Jekyll v3.0.0</generator>
    
      <item>
        <title>Java杂记</title>
        <description>&lt;p&gt;1）在子类覆盖超类的方法时，子类方法不能低于超类方法的可见性，这是为了保证父类指针能引用子类的方法；&lt;/p&gt;

&lt;p&gt;2）java中，抽象类不能被实例化，但可以定义一个抽象类的对象变量，让它去引用非抽象子类的对象； &lt;br /&gt;
3）Java中用于控制可见性的4个访问修饰符：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;仅对本类可见–private；&lt;/li&gt;
  &lt;li&gt;对所有类可见–public；&lt;/li&gt;
  &lt;li&gt;对本包和所有子类可见–protected；&lt;/li&gt;
  &lt;li&gt;对本包可见–默认，即没有表明任何修饰符的情况，这是一种不太受欢迎的形式；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4）完美equal方法的建议：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;显示参数命名为otherobject，稍后需要将它转换成另一个叫做other的变量；&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;检测this和other是否引用同一个对象；
&lt;code&gt;java
if(this == otherObject) return ture; 
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;检测otherobject是否为null，如果为null，返回false
&lt;code&gt;java
if(otherObject == null) return false; 
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;比较this与otherObject是否为同一类。如果equal的语义在每一个子类中有所改变，就使用getClass检测：
&lt;code&gt;java
if(getClass() != otherObjecr.getClass()) return false; 
&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果所有子类都拥有同一语义，就使用instanceof检测：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java
 if(!(otherObject instanceof ClassName)) return false; 
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;将otherObject转换为相应的类类型变量：
&lt;code&gt;java
ClassName other = (ClassName) otherObject; 
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;现在开始对所有需要比较的域进行比较了。使用==比较基本类型域；使用equals比较对象域。如果所有的域都匹配，就返回true，否则返回false。
&lt;code&gt;java
return field1 == other.field1
&amp;amp;&amp;amp; field2.equal(other.field2)
&amp;amp;&amp;amp; ...;
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果在子类中重新定义equals，就要在其中包含调用super.equals(other)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; equals要覆盖Object类的equals方法。&lt;/p&gt;

&lt;p&gt;4） toString：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;只要对象与一个字符串通过操作符“+”连接起来，java编译就会自动调用toString方法，一遍获得这个对象的字符串描述 ；&lt;/li&gt;
  &lt;li&gt;数组的toString要通过调用静态方法Array.toString（多维数组调用Array.deepToString)修正以生成字符串。&lt;/li&gt;
  &lt;li&gt;建议为自己定义的每一个类增加一个toString方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;5） 泛型数组列表 ArrayList：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;void set(int index,T obj) 设置数组列表指定位置的元素值，覆盖原有内容；&lt;/li&gt;
  &lt;li&gt;T get(int index) 获得指定位置的元素值；&lt;/li&gt;
  &lt;li&gt;void add(int index,T obj) 向后移动元素，以便插入元素；&lt;/li&gt;
  &lt;li&gt;T remove(int index) 删除指定位置元素并返回，将后面的元素向前移动；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;6） 对象包装器：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;int intValue() 以int的形式返回Integer对象的值；&lt;/li&gt;
  &lt;li&gt;static String toString(int i) 以一个新String对象的形式返回给定数值i的十进制表示；&lt;/li&gt;
  &lt;li&gt;static String toString(int i,int radix) 返回数值i的基于给定radix参数进制的表示；&lt;/li&gt;
  &lt;li&gt;static String toString(String s) 返回字符串s表示的整型数值（十进制）；&lt;/li&gt;
  &lt;li&gt;static String toString(String s,int radix) 返回字符串s表示的整型数值（radix进制）；&lt;/li&gt;
  &lt;li&gt;static Integer valueOf(String s) 返回用s表示的整型数值进行初始化后的一个新的Integer对象；&lt;/li&gt;
  &lt;li&gt;static Integer valueOf(String s,int radix) 返回用s表示的整型数值进行初始化后的一个新的Integer对象（radix进制）&lt;/li&gt;
  &lt;li&gt;Number parse(String s) 返回s表示的数字值；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;7） 枚举类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;static Enum valueOf(Class enumClass,String name) 返回指定名字、给定类的枚举常量；&lt;/li&gt;
  &lt;li&gt;String toString() 返回枚举常量名；&lt;/li&gt;
  &lt;li&gt;int ordinal() 返回枚举常量在enum声明中的位置，位置从0开始计数；&lt;/li&gt;
  &lt;li&gt;int compareTo(E other) 如果枚举变量出现在other之前，则返回一个负值；如果this==other，则返回0；否则，返回正值。枚举变量的出现次序在enum声明中给出。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;8） Class类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;获得Class类对象的三种方法：
    &lt;ul&gt;
      &lt;li&gt;Class cl=e.getClass();&lt;/li&gt;
      &lt;li&gt;Class cl=Class.forName(className);&lt;/li&gt;
      &lt;li&gt;Class cl=T.class; //T为任意的java类型，如int、Date和Employee等&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;虚拟机为，每个类型管理一个Class对象。因此可以利用==运算符实现两个类型对象的比较操作，如： &lt;code&gt;if(e.getClass() == Employee.class) ...&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;newInstance():
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;说明：&lt;/strong&gt;newInstance方法调用没有参数的构造器，如果没有这样的构造器，则会抛出异常。
&lt;code&gt;java
e.getClass().newInstance();     //创建了一个与e具有相同类型的实例 
Class.forName(str).newInstance()    //按名称str的类名创建对象 
&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;9） 利用反射分析类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;java.lang.reflect包中有三个类Field、Method和Constructor分别用于描述类的域、方法和构造器。&lt;/li&gt;
  &lt;li&gt;三个类都有getName()用来返回项目的名称；&lt;/li&gt;
  &lt;li&gt;三个类都有getModifier()，它将返回一个整型数值，用不同的位开关描述public和static这样的修饰符的使用情况。另外还可以使用Modifier类中的toString()、isPublic()、isPrivate()或isFinal()这样的方法分析；&lt;/li&gt;
  &lt;li&gt;Constructor和Method类中有一个getParameterTypes方法，以数组的形式返回构造器中参数的类型(Class对象)；&lt;/li&gt;
  &lt;li&gt;Method类中还有一个getReturnType()方法，以数组的形式返回方法的返回类型(Class对象);&lt;/li&gt;
  &lt;li&gt;Class类中有getFields()、getMethod()和getConstructor()方法，分别返回类提供的public域、方法和构造器数组，其中包括超类的公有成员；&lt;/li&gt;
  &lt;li&gt;Class类中还有getDeclareFields()、getDeclareMethod()和getDeclareConstructors()方法，返回类中声明的全部域、方法和构造器，其中包括私有和受保护成员，但不包含超类成员；&lt;/li&gt;
  &lt;li&gt;Class类中getName()方法返回项目名称(String)；&lt;/li&gt;
  &lt;li&gt;Class类中还有getType()方法返回项目类型(Class对象)；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;10） 接口：&lt;a href=&quot;http://blog.csdn.net/zdwzzu2006/article/details/4567957&quot;&gt;interface详解(from cdsn)&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 08 Nov 2015 00:00:00 -0800</pubDate>
        <link>http://127.0.0.1:4000/Blog/2015/11/08/java%E6%9D%82%E8%AE%B0/</link>
        <guid isPermaLink="true">http://127.0.0.1:4000/Blog/2015/11/08/java%E6%9D%82%E8%AE%B0/</guid>
        
        <category>Java</category>
        
        <category>编程语言</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>CAT-5电缆</title>
        <description>&lt;en-media hash=&quot;29ef547698535201b95753f8dc213239&quot; style=&quot;cursor: default;cursor: default;cursor: default;&quot; width=&quot;631&quot; type=&quot;image/png&quot; height=&quot;288&quot; /&gt;
&lt;div style=&quot;font-size: 19px;&quot;&gt;

  &lt;p&gt;&lt;strong&gt;绿色线：&lt;/strong&gt;接收数据&amp;lt;/div&amp;gt;&lt;/p&gt;

  &lt;div style=&quot;font-size: 19px;&quot;&gt;

    &lt;p&gt;&lt;strong&gt;橙色线：&lt;/strong&gt;发送数据&amp;lt;/div&amp;gt;&lt;/p&gt;

    &lt;div style=&quot;font-size: 19px;&quot;&gt;

      &lt;p&gt;&lt;strong&gt;白色条纹：&lt;/strong&gt;代表正极&amp;lt;/div&amp;gt;&lt;/p&gt;

      &lt;div style=&quot;font-size: 19px;&quot;&gt;

        &lt;p&gt;&lt;strong&gt;蓝色和棕色线&lt;/strong&gt;：预留给将来扩展带宽(bandwidth)，电线越多带宽越大。&amp;lt;/div&amp;gt;&lt;/p&gt;

        &lt;hr /&gt;

        &lt;p&gt;拓展知识&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;带宽是指单位时间内网络能够传输数据量的最大上限；&lt;/li&gt;
          &lt;li&gt;传输速率用来形容数据在网络中传输的快慢；&lt;/li&gt;
          &lt;li&gt;CAT-5电缆的带宽是10/100Base-T。Base-T是以太网传输速率的标准，1Base-T=1Mb/s，相当于0.25MB/s；&lt;/li&gt;
        &lt;/ul&gt;

        &lt;hr /&gt;

        &lt;p&gt;RJ-45接头接线标准&lt;/p&gt;
        &lt;en-media hash=&quot;a065267ba07ef11f38ed4a29e1d4f7ba&quot; style=&quot;cursor: default;cursor: default;&quot; type=&quot;image/png&quot; /&gt;

        &lt;div style=&quot;font-size: 19px;&quot;&gt;

          &lt;p&gt;两种接线标准可以随意选取，但必须保证电缆两端接法一致&amp;lt;/div&amp;gt;&lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 08 Nov 2015 00:00:00 -0800</pubDate>
        <link>http://127.0.0.1:4000/Blog/2015/11/08/cat-5%E7%94%B5%E7%BC%86/</link>
        <guid isPermaLink="true">http://127.0.0.1:4000/Blog/2015/11/08/cat-5%E7%94%B5%E7%BC%86/</guid>
        
        <category>CAT-5</category>
        
        
        <category>计算机网络</category>
        
      </item>
    
      <item>
        <title>正规表示法</title>
        <description>&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;特殊符号：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;特殊符号&lt;/td&gt;
      &lt;td&gt;代表意义&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:—–&lt;/td&gt;
      &lt;td&gt;:———&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[:alnum:]&lt;/td&gt;
      &lt;td&gt;代表英文大小写字符及数字，亦即0-9，A-Z，a-z&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[:alpha:]&lt;/td&gt;
      &lt;td&gt;代表任何英文大小写字符，亦即 A-Z, a-z&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[:blank:]&lt;/td&gt;
      &lt;td&gt;代表空格键与Tab按键两者&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[:cntrl:]&lt;/td&gt;
      &lt;td&gt;代表键盘上面的控制按键，亦即包括CR，LF，Tab，Del..等等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[:digit:]&lt;/td&gt;
      &lt;td&gt;代表数字，亦即0-9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[:graph:]&lt;/td&gt;
      &lt;td&gt;除了空格符（空格键与Tab按键）外的其他所有按键&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[:lower:]&lt;/td&gt;
      &lt;td&gt;代表小写字符，亦即a-z&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[:print:]&lt;/td&gt;
      &lt;td&gt;代表任何可被打印出来的字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[:punct:]&lt;/td&gt;
      &lt;td&gt;代表标点符号，亦即： “ ‘ ? ! ; : # $…&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[:upper:]&lt;/td&gt;
      &lt;td&gt;代表大写字符，亦即A-Z&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[:space:]&lt;/td&gt;
      &lt;td&gt;任何会产生空白的字符，包括空格键，Tab，CR等等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[:xdigit:]&lt;/td&gt;
      &lt;td&gt;代表16进位的数字类型，因此包括：0-9,A-F,a-f的数字与符号&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;基础正规表示法字符汇整：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;RE字符&lt;/td&gt;
      &lt;td&gt;意义与范例&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:—–&lt;/td&gt;
      &lt;td&gt;:——–&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;^world&lt;/td&gt;
      &lt;td&gt;意义：待搜寻的字符串(world)在行首&lt;br /&gt;范例：待搜寻行首为#开始的那一行，并列出行号&amp;lt;/br&amp;gt; &lt;br /&gt;grep -n ‘^#’ re.txt&amp;lt;/br&amp;gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;world$&lt;/td&gt;
      &lt;td&gt;意义：待搜寻的字符串(word)在行尾&lt;br /&gt;范例：将行尾为！的那行打印出来，并列出行号&amp;lt;/br&amp;gt; &lt;br /&gt;grep -n ‘!$’ re.txt &amp;lt;/br&amp;gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;.&lt;/td&gt;
      &lt;td&gt;意义：代表一定有一个任意字节的字符！&lt;br /&gt;范例：搜寻的字串可以是 (eve) (eae) (eee) (e e)， 但不能仅有 (ee) ！亦即 e 与 e 中间一定仅有一个字节，而空白字节也是字节&amp;lt;/br&amp;gt; &lt;br /&gt;grep -n ‘e.e’ re.txt&amp;lt;/br&amp;gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\&lt;/td&gt;
      &lt;td&gt;意义：跳脱字符，将特殊符号的特殊意义去除 &lt;br /&gt;范例：搜寻含有单引号 ‘ 的那一行&amp;lt;/br&amp;gt;&lt;br /&gt;grep -n &#39; re.txt&amp;lt;/br&amp;gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;*&lt;/td&gt;
      &lt;td&gt;意义：重复零个到无穷多个的前一个 RE 字符&lt;br /&gt;范例：找出含有 (es) (ess) (esss) 等等的字串，注意，因为 * 可以是 0 个，所以 es 也是符合带搜寻字串。另外，因为 * 为重复前一个 RE 字符的符号， 因此，在 * 之前必须要紧接著一个 RE 字符喔！例如任意字节则为 .* &amp;lt;/br&amp;gt;&lt;br /&gt;grep -n ‘ess*’ re.txt&amp;lt;/br&amp;gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[list]&lt;/td&gt;
      &lt;td&gt;意义：字节集合的 RE 字符，里面列出想要撷取的字节&lt;br /&gt;范例：搜寻含有 (gl) 或 (gd) 的那一行，需要特别留意的是，在 [] 当中谨代表一个待搜寻的字节， 例如 a[afl]y 代表搜寻的字串可以是 aay, afy, aly 即 [afl] 代表 a 或 f 或 l 的意思&amp;lt;/br&amp;gt;&lt;br /&gt;grep -n ‘g[ld]’ re.txt&amp;lt;/br&amp;gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[n1-n2]&lt;/td&gt;
      &lt;td&gt;意义：字节集合的 RE 字符，里面列出想要撷取的字节范围&lt;br /&gt;范例：搜寻含有任意数字的那一行！需特别留意，在字节集合 [] 中的减号 - 是有特殊意义的，他代表两个字节之间的所有连续字节！但这个连续与否与 ASCII 编码有关，因此，你的编码需要配置正确(在 bash 当中，需要确定 LANG 与 LANGUAGE 的变量是否正确！) 例如所有大写字节则为 [A-Z]&amp;lt;/br&amp;gt;&lt;br /&gt;grep -n ‘[A-Z]’ re.txt&amp;lt;/br&amp;gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[^list]&lt;/td&gt;
      &lt;td&gt;意义：字节集合的 RE 字符，里面列出不要的字串或范围&lt;br /&gt;范例：搜寻的字串可以是 (oog) (ood) 但不能是 (oot) ，那个 ^ 在 [] 内时，代表的意义是『反向选择』的意思。 例如，我不要大写字节，则为 [^A-Z]。但是，需要特别注意的是，如果以 grep -n [^A-Z] re.txt 来搜寻，却发现该文件内的所有行都被列出，为什么？因为这个 [^A-Z] 是非大写字节的意思， 因为每一行均有非大写字节，例如第一行的 “Open Source” 就有 p,e,n,o…. 等等的小写字&amp;lt;/br&amp;gt;&lt;br /&gt;grep -n ‘oo[^t]’ re.txt&amp;lt;/br&amp;gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\{n,m\}&lt;/td&gt;
      &lt;td&gt;意义：连续 n 到 m 个的前一个 RE 字符&lt;br /&gt;意义：若为 {n} 则是连续 n 个的前一个 RE 字符&amp;lt;/br&amp;gt;&lt;br /&gt;意义：若是 {n,} 则是连续 n 个以上的前一个 RE 字符&amp;lt;/br&amp;gt; &lt;br /&gt;范例：在 g 与 g 之间有 2 个到 3 个的 o 存在的字串，亦即 (goog)(gooog)&amp;lt;/br&amp;gt;&lt;br /&gt;grep -n ‘go{2,3}g’ re.txt&amp;lt;/br&amp;gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Sat, 07 Nov 2015 00:00:00 -0800</pubDate>
        <link>http://127.0.0.1:4000/Blog/2015/11/07/%E6%AD%A3%E8%A7%84%E8%A1%A8%E7%A4%BA%E6%B3%95/</link>
        <guid isPermaLink="true">http://127.0.0.1:4000/Blog/2015/11/07/%E6%AD%A3%E8%A7%84%E8%A1%A8%E7%A4%BA%E6%B3%95/</guid>
        
        <category>Linux</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>Intent</title>
        <description>&lt;h2 id=&quot;intentintent&quot;&gt;Intent与Intent的概念&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;intent：Intent是一种在不同组件之间传递的请求消息，是应用程序发出的请求和意图。作为一个完整的消息传递机制，Intent不仅需要发送端，还需要接收端。&lt;/li&gt;
  &lt;li&gt;IntentFilter：用来描述一个基本组件的地址&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;intent&quot;&gt;显示Intent&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;明确指出了目标组件名称&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;java
Intent intent=new Intent();
intent.setComponent(new ComponentName(&quot;com.moilk.learningintent&quot;,&quot;com.moilk.learningintent.Aty1&quot;));
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;intent-1&quot;&gt;隐式Intent&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;没有明确指出目标组件名称,使用IntentFilter来寻找与隐式Intent相关的对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;```java
// 在AndroidManifest中为Activity添加intent-filter&lt;/p&gt;
&lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
&lt;/intent-filter&gt;

&lt;p&gt;// 
```&lt;/p&gt;
</description>
        <pubDate>Sat, 07 Nov 2015 00:00:00 -0800</pubDate>
        <link>http://127.0.0.1:4000/Blog/2015/11/07/intent/</link>
        <guid isPermaLink="true">http://127.0.0.1:4000/Blog/2015/11/07/intent/</guid>
        
        <category>Android</category>
        
        
        <category>Android开发</category>
        
      </item>
    
      <item>
        <title>Android四大核心组件</title>
        <description>&lt;h2 id=&quot;activity&quot;&gt;Activity&lt;/h2&gt;

&lt;h4 id=&quot;section&quot;&gt;1. 概念&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;一个Activity是一个应用程序组件，提供一个屏幕，用户可以用来交互为了完成某项任务，例如拨号、拍照、发送email、看地图。每一个activity被给予一个窗口，在上面可以绘制用户接口。窗口通常充满屏幕，但也可以小于屏幕而浮于其它窗口之上。&lt;/li&gt;
  &lt;li&gt;一个application通常包含各种各样的activity，这些activity彼此间没有紧密的约束。通常，有一个activity作为application首次运行所展示的界面。然后每个activity又可以启动其他activity来执行不同的操作，每当一个新的activity启动时，先前的activity停止工作，被操作系统保存在回收栈中。当一个新的activity启动时，它就被压入栈中并取得”user focus“，当用户处理完当前activity返回时，这个activity从栈中pop出来，先前的activity恢复运行。&lt;/li&gt;
  &lt;li&gt;当一个activity因为另一个activity的启动而停止，这种状态的改变会通过activity生命周期的回调方法产生通知。因为状态的改变一个activity可能会接收到几个回调方法的通知，比如系统是不是创建、停止、恢复或者销毁了它。这些回调方法为你提供了一个机会来执行特定的操作以回应状态的改变。比如当一个activity停止时，你的activity需要释放掉一些提供网络或者数据库连接的对象；当一个activity恢复时，需要重新获取一些必要的资源，恢复被中断的操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;2. 三种状态&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;运行&lt;/li&gt;
  &lt;li&gt;停止&lt;/li&gt;
  &lt;li&gt;暂停&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;3. 生命周期的七个方法&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://f.picphotos.baidu.com/album/s%3D740%3Bq%3D90/sign=4fca805e978fa0ec7bc7660916ac28d3/9d82d158ccbf6c81ad106e85ba3eb13533fa40b3.jpg&quot; alt=&quot;Android生命周期&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;activity-1&quot;&gt;4. Activity的操作&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;开启另一个Activity:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;java
Intent intent = new Intent(MainActivity.this, Main2Activity.class);
startActivity(intent);
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;关闭Activity: finish();&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;activity-2&quot;&gt;5. Activity的数据传递&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;简单数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;java
intent.putExtra(&quot;text&quot;,&quot;简单数据传递&quot;);   // 在传出数据的Activity中
...
getIntent().getStringExtra(&quot;text&quot;); // 在传入数据的Activity中，返回对应类型
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;复杂数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;java
// 在传出数据的Activity中
Bundle bundle=new Bundle();
bundle.putString(&quot;text&quot;,&quot;复杂数据传输&quot;);
intent.putExtras(bundle);
...
// 在传入数据的Activity中
Bundle bundle=getIntent().getExtras();
tvOut.setText(bundle.getString(&quot;text&quot;));
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;回传&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;```java
// 在即将被关闭的Activity中
Intent intent=new Intent();
intent.putExtra(“result”,”返回数据”);
setResult(0,intent);
…
// 在接收结果的Activity中&lt;/p&gt;

&lt;p&gt;// 不用startActivity()
startActivityForResult(intent,0);
…
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        String result=data.getStringExtra(“result”);
        tvOut.setText(result);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    super.onActivityResult(requestCode, resultCode, data); } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;service&quot;&gt;Service&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;创建Service&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;```java
// 新建一个类继承Service
//Service的生命周期函数就onCreate和onDestroy两个
public class EchoService extends Service {
    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null; // 返回调度者
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onCreate() {
    System.out.println(&quot;onCreate()&quot;);
    super.onCreate();
}

@Override
public void onDestroy() {
    System.out.println(&quot;onDestroy()&quot;);
    super.onDestroy();
} }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;// 像启动一个Activity一样启动Service
private serviceIntent=new Intent(this,EchoService.class);
// Service要由系统调度，不能自己new一个出来
startService(serviceIntent);
// 停止Service
stopService(serviceIntent);
```&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Activity与Service的连接&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;```java
// 绑定服务，此时要求Activity继承ServiceConnection接口
// 实现onServiceConnected和onServiceDisconnected函数
bindService(serviceIntent,this, Context.BIND_AUTO_CREATE);
…
// 在Service中，建立调度者内部类
public class EchoServiceBinder extends Binder {
        /**
         * 得到服务的实例
         * @return 服务的实例
         */
        public EchoService getService() {
            return EchoService.this;
        }
}&lt;/p&gt;

&lt;p&gt;// onBind函数要返回调度者的类
private final EchoServiceBinder echoServiceBinder = new EchoServiceBinder();&lt;/p&gt;

&lt;p&gt;@Override
    public IBinder onBind(Intent intent) {
        System.out.println(“onBind()”);
        return echoServiceBinder;
    }
// 这样，在Activity与Service绑定时就会触发onServiceConnected函数
// onServiceConnected的两个参数name为被绑定的Service，service为调度者
    public void onServiceConnected(ComponentName name, IBinder service) {
        System.out.println(“onServiceConnected()”);
        // 调用调度者的getService()函数得到Service的引用，
        // 这样便可在Activity中得到Service的数据
        echoService= ((EchoService.EchoServiceBinder) service).getService();
    }
```&lt;/p&gt;

&lt;h2 id=&quot;broadcast-receiver&quot;&gt;Broadcast Receiver&lt;/h2&gt;

&lt;p&gt;说明： 广播接收者 缺点：反应比较慢、不能用来传输大数据；&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;静态注册&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;```java
// 新建一个类继承BroadcastReceiver
public class MyBC extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        System.out.println(“onReceive():”+intent.getStringExtra(“text”));
    }
}
…
// 在AndroidManife.xml里边添加一个recevice&lt;/p&gt;
&lt;receiver android:name=&quot;.MyBC&quot;&gt; &lt;/receiver&gt;
&lt;p&gt;…
// 在Activity中向MyBC发送一个广播，receiver中便可接收到
Intent intent=new Intent(MainActivity.this,MyBC.class);
intent.putExtra(“text”,”moilk”);
sendBroadcast(intent);
```&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;动态注册、注销&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;java
// 首先，不用在AndroidManifest中生命receiver
// 创建一个接收器对象
private final MyBC myBC=new MyBC();
// 注册接收器
registerReceiver(myBC, new IntentFilter(MyBC.ACTION));
// 其中，
public static final String ACTION=&quot;com.moilk.usingbc.intent.action.MyBC&quot;;
// 注销接收器
unregisterReceiver(myBC);
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;contentprovider&quot;&gt;ContentProvider&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;ContentProvider的用法：获取联系人&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;java
Cursor cursor=getContentResolver().query(ContactsContract.Contacts.CONTENT_URI, null, null, null, null);
while (cursor.moveToNext()) {
            System.out.println(&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&quot;
                    +cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME)));
}
&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 07 Nov 2015 00:00:00 -0800</pubDate>
        <link>http://127.0.0.1:4000/Blog/2015/11/07/android%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</link>
        <guid isPermaLink="true">http://127.0.0.1:4000/Blog/2015/11/07/android%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</guid>
        
        <category>Android</category>
        
        
        <category>Android开发</category>
        
      </item>
    
  </channel>
</rss>
