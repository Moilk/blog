---
layout: post
title: 算法 - 斐波那契数列
tags:  [算法]
categories: [算法]
author: Moilk
excerpt: "在这写上摘记..."
---
　　斐波那契数列中每个数都是其两个直接前项的和，其生成规则如下所示：  

$$
F_n=
\begin{cases} 
F_{n-1}+F_{n-2} & \text{如果n>1} \\ 
1 & \text{如果n=1} \\ 
0 & \text{如果n=0} 
\end{cases} 
$$.

### 指数算法  
　　要求斐波那契数列的第n项值一种简单的方法就是使用递归  
> function fib(n)  
if n=0: return 0;  
if n=1: return 1;  
return fib(n-1)+fib(n-2);  

　　但是使用递归来计算第n项，它消耗的资源是指数级增长的。如下图所示,一个fib(n)会触发一连串的递归操作，而这些操作中有很多步骤是重复的。因此，这个算法虽然正确，但是效率太低。  
![指数算法]({{site.baseurl}}/assets/images/algorithms/01-1.png)  

### 多项式算法  
　　递归的方法对资源的消耗太大，更合理的方法是使用循环来完成，随时保存中间结果。  
> function fib(n)  
if n=0: return 0;  
create an array f[0...n]  
f[0]=0,f[1]=1  
for i=2...n:  
　f[i]=f[i-1]+f[i-2]  
return f[n]  

以下为java实现的两种计算斐波那契数列第n项算法：

```java
import java.util.Scanner;

public class Fibonacci {
	public static void main(String argv[]){
	// 输入
		System.out.print("请输入一个整数:");
		Scanner  x=new Scanner(System.in);
		int n=x.nextInt();

	// 运算
		Fibonacci fib=new Fibonacci();
		long fibn=fib.fib1(n);

	// 结果显示
		System.out.println("fib(n)="+fibn);
	}

	/**
	 * 指数算法
	 * n大于40延时就明显了
	 * @param n
	 * @return
	 */
	public long fib1(int n){
		if(n==0){
			return 0;
		}
		if(n==1){
			return 1;
		}
		return fib1(n-1)+fib1(n-2);
	}

	/**
	 * 多项式算法
	 * 由于long的范围，结果在n属于[0,92]正确。
	 * @param n
	 * @return
	 */
	public long fib2(int n){
		if(n==0)	return 0;

		long[] f=new long[n+1];
		f[0]=0;
		f[1]=1;
		for(int i=2;i<=n;i++){
			f[i]=f[i-1]+f[i-2];
		}
		return f[n];
	}
}
```